local function callback(self, message_id, message, sender)
	pprint("GO callback", message_id, message, sender)
end

local function play_animation(self)
	spine.play_anim(self.url, "run", go.PLAYBACK_ONCE_FORWARD, {}, 
	function(self, message_id, message, sender)
			if (message_id == hash("spine_animation_done")) then
				spine.play_anim(self.url, "run", go.PLAYBACK_ONCE_FORWARD, {}, 
					function(self, message_id, message, sender)
						assert(type(message_id) ~= "string")
						pprint("GO callback", message_id, message, sender)
						if (message_id == hash("spine_animation_done")) then
							spine.play_anim(self.url, "run", go.PLAYBACK_LOOP_FORWARD, {}, callback)
						end
					end)
			end
		end)
	self.is_playing = true
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.countdown = 2
	self.url = "#spinemodel"
	
	-- Basic animation setup
	spine.play_anim(self.url, "ddd", go.PLAYBACK_LOOP_FORWARD)
	spine.set_skin(self.url, "default")
	
	-- Properties demonstration
	print("Properties")
	print("current animation:", go.get(self.url, "animation"))
	print("current skin:", go.get(self.url, "skin"))
	go.set(self.url, "skin", hash("default"))
	go.set(self.url, "skin", hash(""))
	
	-- Attachments
	spine.set_attachment(self.url, "mouth", "mouth-smile")
	
	-- Bones
	local bone = spine.get_go(self.url, "gun-tip")
	print("bone", bone)
	go.set_parent("blob", bone)
	self.bone = bone
	
	-- Multi-track animation
	spine.play_anim(self.url, "idle", go.PLAYBACK_LOOP_FORWARD, { track = 1 })
	spine.play_anim(self.url, "aim", go.PLAYBACK_LOOP_FORWARD, { track = 2 })
	spine.set_ik_target(self.url, "aim-ik", "ik-target")
	self.ik_mode = "follow" -- track current IK mode
end

function final(self)
end

function update(self, dt)
	self.countdown = self.countdown - 1
	if self.countdown == 0 then
		--spine.cancel("#spinemodel")
	end
end

function on_message(self, message_id, message, sender)
	pprint("message", message_id, message)
end

function on_input(self, action_id, action)
	if action_id == nil then
		self.mouse_pos = vmath.vector3(action.x, action.y, 0)
		-- Move the IK target only in follow mode
		if self.ik_mode == "follow" then
			go.set("ik-target", "position", self.mouse_pos)
		end
	elseif action_id == hash("mouse_button_right") and action.pressed then
		if self.is_playing then
			spine.cancel(self.url, { track = 1 })
			self.is_playing = false
		else
			play_animation(self)
		end
	elseif action_id == hash("mouse_button_left") and action.pressed then
		spine.play_anim(self.url, "shoot", go.PLAYBACK_ONCE_FORWARD, { track = 3 })
	elseif action_id == hash("key_space") and action.pressed then
		-- Toggle between fixed and follow mode
		if self.ik_mode == "follow" then
			-- Switch to fixed mode - set IK target to current mouse position
			go.set("ik-target", "position", self.mouse_pos)
			self.ik_mode = "fixed"
			print("GO IK mode: fixed at current mouse position")
		else
			-- Switch back to follow mode
			self.ik_mode = "follow"
			print("GO IK mode: follow mouse")
		end
	elseif action_id == hash("key_c") and action.pressed then
		-- Test cursor control on different tracks
		print("GO: Testing cursor control")
		go.set(self.url, "cursor", 0.5)  -- Set track 1 cursor to 50% (old API)
		print("GO: Set track 1 cursor to 0.5 using go.set")
		
		-- Note: Spine GO component uses go.set/go.get for properties, not spine.set_cursor
		-- This is different from GUI which has gui.set_spine_cursor functions
		local cursor = go.get(self.url, "cursor")
		print("GO: Current cursor value:", cursor)
	elseif action_id == hash("key_p") and action.pressed then
		-- Test playback rate control on different tracks
		print("GO: Testing playback rate control")
		go.set(self.url, "playback_rate", 2.0)  -- Set track 1 to double speed (old API)
		print("GO: Set track 1 playback rate to 2.0 using go.set")
		
		-- Note: Spine GO component uses go.set/go.get for properties, not spine.set_playback_rate
		-- This is different from GUI which has gui.set_spine_playback_rate functions
		local rate = go.get(self.url, "playback_rate")
		print("GO: Current playback rate:", rate)
	end
end

function on_reload(self)
end 